"""
Copyright (C) 2009-2021 Splunk Inc. All Rights Reserved.

Helper methods for mobile alerts.
"""
import logging
import os
import warnings
from base64 import b64decode

from spacebridgeapp.dashboard.generate_dashboard import create_dashboard_description_table
from spacebridgeapp.dashboard.parse_search import get_string_field
from spacebridgeapp.data.dashboard_data import DashboardVisualizationId
from spacebridgeapp.request.dashboard_request_processor import fetch_dashboard_description, get_list_dashboard_data, \
    get_search_job_content, get_search_job_dashboard_data
from spacebridgeapp.search.input_token_support import set_default_token_values

warnings.filterwarnings('ignore', '.*service_identity.*', UserWarning)

from spacebridgeapp.util import py23

os.environ['PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION'] = 'python'

import jsonpickle
import json
import asyncio

from cloudgateway.device import EncryptionKeys
from cloudgateway.encryption_context import EncryptionContext
from cloudgateway.private.sodium_client.sharedlib_sodium_client import SodiumClient, SodiumOperationError
from http import HTTPStatus
from spacebridgeapp.util import constants
from spacebridgeapp.data.alert_data import CallToAction, Notification, Alert, Detail, RecipientDevice, ScopedSnooze
from spacebridgeapp.util.app_info import fetch_display_app_name
from spacebridgeapp.alerts import notifications
from spacebridgeapp.rest.services.kvstore_service import KVStoreCollectionAccessObject as KvStoreAccessor
from spacebridgeapp.messages.request_context import RequestContext
from spacebridgeapp.request.request_processor import SpacebridgeAuthHeader
from cloudgateway.private.encryption.encryption_handler import encrypt_for_send, sign_detached
from functools import partial
from spacebridgeapp.rest.devices.util import public_keys_for_device
from spacebridgeapp.exceptions.key_not_found_exception import KeyNotFoundError
from spacebridgeapp.exceptions.splunk_api_exceptions import EncryptionKeyError 
from spacebridgeapp.util.constants import SUBJECT, SEVERITY, CALL_TO_ACTION_URL, CALL_TO_ACTION_LABEL, \
    ALERT_TIMESTAMP_FIELD, ALERT_ID, ALERT_MESSAGE, CONFIGURATION, SAVED_SEARCH_RESULT, RESULTS_LINK, \
    SEARCH_ID, OWNER, APP, SEARCH_NAME, TOKEN, FIELDNAME, ALERT_SUBJECT, DASHBOARD_TOGGLE, ATTACH_DASHBOARD_TOGGLE, \
    ALERT_DASHBOARD_ID, RESULT, ATTACH_TABLE_TOGGLE, SIGN_PUBLIC_KEY

from spacebridgeapp.rest.clients.async_kvstore_client import AsyncKvStoreClient
from spacebridgeapp.util.time_utils import get_current_timestamp


def preprocess_payload(alert_payload):
    """
    If our custom fields are not populated by the user, splunk will not send them in the payload. So we just populate those
    fields as empty string for simplicity.
    :param alert_payload:
    :return:

    """
    if SUBJECT not in alert_payload[CONFIGURATION].keys():
        alert_payload[CONFIGURATION][SUBJECT] = ""

    if ALERT_MESSAGE not in alert_payload[CONFIGURATION].keys():
        alert_payload[CONFIGURATION][ALERT_MESSAGE] = ""

    if CALL_TO_ACTION_LABEL not in alert_payload[CONFIGURATION].keys():
        alert_payload[CONFIGURATION][CALL_TO_ACTION_LABEL] = ""

    if CALL_TO_ACTION_URL not in alert_payload[CONFIGURATION].keys():
        alert_payload[CONFIGURATION][CALL_TO_ACTION_URL] = ""

    if TOKEN not in alert_payload[CONFIGURATION].keys():
        alert_payload[CONFIGURATION][TOKEN] = ""

    if FIELDNAME not in alert_payload[CONFIGURATION].keys():
        alert_payload[CONFIGURATION][FIELDNAME] = ""

def persist_alert(log: logging.Logger, alert, session_key):
    """
    Takes an alert (json object), a server uri and a splunk session key and posts each
    alert into KV Store.

    Currently does it synchronously but we should optimize by making each post request async.

    Arguments:
        server_uri {string} -- uri of the server
        alert {Alert} -- Alert object to be persisted to KV store
        session_key {string} -- session key given by Splunk. Used for auth.
    """

    mobile_alerts_accessor = KvStoreAccessor(collection=constants.MOBILE_ALERTS_COLLECTION_NAME,
                                             owner="nobody",
                                             session_key=session_key)

    try:
        r, response = mobile_alerts_accessor.insert_single_item_as_json(jsonpickle.encode(alert))

        log.info("Response from KV Store: " + response.decode('ascii'))
        return json.loads(response)

    except Exception:
        log.exception("Error writing alert to KV Store")
        return {}


async def persist_recipient_devices(log: logging.Logger, request_context, key, recipient_devices, alert_payload, async_client):
    """Given an alert payload generated by splunk and an alert id of the alert as it is
       stored in KV store, creates a RecipientDevice record in KV Store for each device that
       should receive the alert and persists that device in KV Store. Each post request for
       each device is handled asynchronously.

       Arguments:
           key {string} -- key of alert in KV Store
           recipient_devices {List of String} -- List of device ids which should receive alert
           alert_payload {json} -- Alert payload generated by splunk
           session_key {string} -- Session key given by the alert
           async_client {AsyncKvStoreClient} -- instance of kv store client to perform async requests
       """

    deferred_responses = []

    for device_id in recipient_devices:
        payload = RecipientDevice(alert_id=key, device_id=device_id, timestamp=alert_payload[CONFIGURATION][
            ALERT_TIMESTAMP_FIELD])
        deferred_responses.append(async_client.async_kvstore_post_request(
            collection=constants.ALERTS_RECIPIENT_DEVICES_COLLECTION_NAME,
            data=jsonpickle.encode(payload),
            auth_header=request_context.auth_header))

    # Wait until all requests have completed
    # TODO: Remove 'gather' b/c lack of reliability in the past and tendency to overwhelm Splunk
    responses = await asyncio.gather(*deferred_responses, return_exceptions=True)

    successes = []
    exceptions = []

    for i in range(len(responses)):
        if isinstance(responses[i], Exception):
            exceptions.append(responses[i])
        else:
            successes.append(responses[i])

    if exceptions:
        log.error("Encountered exceptions persisting recipient devices, e=%s", str(exceptions))

async def should_send(log: logging.Logger,
                      request_context: RequestContext,
                      async_kvstore_client: AsyncKvStoreClient,
                      notification: Notification,
                      device_id: str):
    """
    should_send determines if a notification should be sent to a particular device.
    If the alert is snoozed for that device, then we shouldn't send it.

    :param log:
    :param request_context: Context for authenticating with KVStore
    :param async_kvstore_client: Client to talk with KVStore
    :param notification: Notification which is going to be sent to the device
    :param device_id: ID of the device in question
    :return: True if the notification should be sent, else False
    """

    current_timestamp = str(get_current_timestamp())

    # First we will check for snoozing, and if the alert is snoozed, we will ignore it
    # Query fetches all snoozes with the correct device ID, and are not expired yet, i.e. end_time > now
    query = {constants.AND_OPERATOR: [{constants.DEVICE_ID: device_id},
                                      {constants.END_TIME: {constants.GREATER_THAN_OPERATOR: current_timestamp}}]}
    params = {constants.QUERY: json.dumps(query)}
    log.debug('Fetching scoped snoozes with params %s', params)

    snoozed_scopes = await async_kvstore_client.async_kvstore_get_request(
        collection=constants.SNOOZED_SCOPES_COLLECTION_NAME,
        auth_header=request_context.auth_header,
        params=params
    )
    if snoozed_scopes.code != HTTPStatus.OK:
        err_text = await snoozed_scopes.text()
        log.info('Failed to fetch snoozes while sending notifications with message %s', err_text)
        return True

    snoozed_scopes_json = await snoozed_scopes.json()
    for snoozed_scopes in snoozed_scopes_json:
        snoozed_scope = ScopedSnooze.from_json(snoozed_scopes)
        if snoozed_scope.scope == constants.SNOOZE_ALL_SCOPE:
            log.debug('Not sending notification as all alerts are snoozed for device with id %s', device_id)
            return False

    return True

async def send_push_notification(log: logging.Logger,
                                 request_context,
                                 notification,
                                 recipient_devices,
                                 async_kvstore_client,
                                 async_spacebridge_client,
                                 async_splunk_client):
    """
    Given a notification object and a list of device ids, sends a post request to the Spacebridge notif API
    for each device id
    :param log:
    :param request_context:
    :param notification: notification object to be sent
    :param recipient_devices: list of device id strings
    :param async_kvstore_client: AsyncKVStoreClient
    :param async_spacebridge_client: AsyncSpacebridgeClient
    :param async_splunk_client: AsyncSpacebridgeClient
    :return:
    """

    sodium_client = SodiumClient(log.getChild('sodium_client'))
    deployment_info = await async_splunk_client.async_get_deployment_info(request_context.auth_header)

    # fetch sign public key from deployment info endpoint
    if deployment_info.code == HTTPStatus.OK:
        response = await deployment_info.json()
        sign_public_key = b64decode(response.get(SIGN_PUBLIC_KEY, ""))
        encryption_keys = EncryptionKeys(sign_public_key, None, None, None)
        encryption_context = EncryptionContext(encryption_keys)

    else:
        error = await deployment_info.text()
        log.exception("Unable to fetch signing public key with error_code=%s", str(deployment_info.code))
        raise EncryptionKeyError(error, deployment_info.code)


    sender_id = encryption_context.sign_public_key(transform=encryption_context.generichash_raw)
    sender_id_hex = py23.encode_hex_str(sender_id)

    headers = {'Content-Type': 'application/x-protobuf', 'Authorization': sender_id_hex}
    async_sign_payload = partial(async_splunk_client.sign_payload, request_context.auth_header)

    successes = []
    exceptions = []

    for device_id_str in recipient_devices:
        log.debug(f'Attempting to send push notification to device={device_id_str}')
        device_id = device_id_str.encode('utf-8')
        device_id_raw = b64decode(device_id)

        try:
            if not await should_send(log, request_context, async_kvstore_client, notification, device_id_str):
                continue
            _, receiver_encrypt_public_key = await public_keys_for_device(device_id_raw,
                                                                          request_context.auth_header,
                                                                          async_kvstore_client)

            encryptor = partial(encrypt_for_send,
                                sodium_client,
                                receiver_encrypt_public_key)

            notification_request = await notifications.async_build_notification_request(log,
                                                                            device_id, device_id_raw, sender_id,
                                                                            notification,
                                                                            encryptor, async_sign_payload)

            # Send post request asynchronously
            r = await async_spacebridge_client.async_send_notification_request(
                auth_header=SpacebridgeAuthHeader(sender_id),
                data=notification_request.SerializeToString(),
                headers=headers)
            successes.append({"Recipient device id": device_id_str, "Status": r.code })

        except KeyNotFoundError:
            log.info("Public key not found for device_id=%s", device_id)
            exceptions.append({"Recipient device id": device_id_str, "Response": r.code})

        except SodiumOperationError:
            log.warning("Sodium operation failed! device_id=%s", device_id)
            exceptions.append({"Recipient device id": device_id_str, "Response": r.code})
        except Exception as e:
            log.exception(f'unexpected error when sending push notification for device_id={device_id}')
            exceptions.append({"Recipient device id": device_id_str, "Response": r.code})

    log.info("Finished sending push notifications with responses=%s", str(successes))

    if exceptions:
        log.error("Encountered exceptions sending pushing notifications to devices=%s", str(exceptions))

    return [successes, exceptions]

# Helper object for Dashboard objects which can be returned in deferred
class DashboardTuple(object):
    """
    Helper object to pass around dashboard objects in deferred
    """

    def __init__(self, dashboard_description=None, list_dashboard_data=None):
        self.dashboard_description = dashboard_description
        self.list_dashboard_data = list_dashboard_data


async def fetch_dashboard_url_dashboard_tuple(log: logging.Logger,
                                              request_context,
                                              dashboard_url=None,
                                              async_splunk_client=None,
                                              async_kvstore_client=None,
                                              input_tokens=None):
    """
    Helper method which fetches dashboard objects from a dashboard_url
    """
    # Fetch Dashboard Description, for alerts don't return params
    try:
        dashboard_description = await fetch_dashboard_description(log,
                                                                  request_context,
                                                                  dashboard_id=dashboard_url,
                                                                  show_refresh=False,
                                                                  async_splunk_client=async_splunk_client,
                                                                  async_kvstore_client=async_kvstore_client)

        set_default_token_values(input_tokens, dashboard_description.input_tokens)
        # Find all the visualizations in the dashboard and get the data
        list_dashboard_data = await get_list_dashboard_data(log,
                                                            request_context,
                                                            dashboard_description=dashboard_description,
                                                            input_tokens=input_tokens,
                                                            async_splunk_client=async_splunk_client)

        log.info("DashboardData List Size len=%d", len(list_dashboard_data))
        return DashboardTuple(dashboard_description, list_dashboard_data)
    except Exception as e:
        log.exception("Exception fetching dashboard=%s", str(dashboard_url))
        return DashboardTuple()


async def fetch_search_job_dashboard_tuple(log: logging.Logger,
                                           request_context, alert_payload, async_splunk_client=None):
    """
    Helper method to fetch dashboard objects from a search_job
    """
    app_name = alert_payload[APP]
    owner = alert_payload[OWNER]
    search_id = alert_payload[SEARCH_ID]
    configuration = alert_payload[CONFIGURATION]
    alert_message = configuration[ALERT_MESSAGE]
    alert_subject = configuration[ALERT_SUBJECT]
    list_dashboard_data = []

    # Get search_content_when_done, function will retry until search job is_done
    search_job_content = await get_search_job_content(log,
                                                      auth_header=request_context.auth_header,
                                                      owner=owner,
                                                      app_name=app_name,
                                                      search_id=search_id,
                                                      async_splunk_client=async_splunk_client)

    if not search_job_content:
        return DashboardTuple()

    # Create fake dashboard_description
    display_app_name = await fetch_display_app_name(log,request_context, app_name, async_splunk_client)
    dashboard_description = create_dashboard_description_table(log,
                                                               owner=owner,
                                                               app_name=app_name,
                                                               display_app_name=display_app_name,
                                                               description=alert_message,
                                                               visualization_title=alert_subject,
                                                               query=get_string_field('reportSearch',
                                                                                      search_job_content.properties))

    # Pluck out the visualization to retrieve the visualization_id
    dashboard_visualization = dashboard_description.get_first_visualization()

    # Create the fake dashboard_visualization_id
    dashboard_visualization_id = DashboardVisualizationId(dashboard_id=dashboard_description.dashboard_id,
                                                          visualization_id=dashboard_visualization.id)

    # Append dashboard_data based on search_id with fake dashboard_visualization_id
    dashboard_data = await get_search_job_dashboard_data(log,
                                                         request_context,
                                                         owner=owner,
                                                         app_name=app_name,
                                                         search_id=search_id,
                                                         dashboard_visualization_id=dashboard_visualization_id,
                                                         async_splunk_client=async_splunk_client)
    list_dashboard_data.append(dashboard_data)

    return DashboardTuple(dashboard_description, list_dashboard_data)


async def build_alert(log: logging.Logger,
                      request_context, alert_payload=None, async_splunk_client=None, async_kvstore_client=None):
    """
    Takes an alert payload and a session key and creates an Alert object
    which is to be persisted into KV Store. The session key is required
    because a network call needs to be made to fetch the attached dashboard's
    metadata.

    :param log:
    :param request_context:
    :param alert_payload: {json} -- payload of alert sent by Splunk on alert trigger
    :param async_splunk_client:
    :param async_kvstore_client:
    :return: Alert -- alert object which contains all the necessary information for the alert,
        which is to be persisted into KV Store.
    """

    configuration = alert_payload[CONFIGURATION]
    dashboard_url = None
    dashboard_tuple = DashboardTuple()

    if configuration[DASHBOARD_TOGGLE] == ATTACH_DASHBOARD_TOGGLE and ALERT_DASHBOARD_ID in configuration.keys():
        dashboard_url = configuration[ALERT_DASHBOARD_ID]
        if alert_payload[RESULT] and configuration[FIELDNAME] in alert_payload[RESULT].keys():
            input_tokens = {configuration[TOKEN]: alert_payload[RESULT][configuration[FIELDNAME]]}
        else:
            input_tokens = {}

        # Fetch Dashboard Description, for alerts don't return params
        dashboard_tuple = await fetch_dashboard_url_dashboard_tuple(log,
                                                                    request_context,
                                                                    dashboard_url,
                                                                    async_splunk_client,
                                                                    async_kvstore_client,
                                                                    input_tokens=input_tokens)

    elif configuration[DASHBOARD_TOGGLE] == ATTACH_TABLE_TOGGLE:
        dashboard_tuple = await fetch_search_job_dashboard_tuple(log,
                                                                 request_context,
                                                                 alert_payload,
                                                                 async_splunk_client)

    call_to_action = CallToAction(uri=configuration[CALL_TO_ACTION_URL],
                                  title=configuration[CALL_TO_ACTION_LABEL])

    display_app_name = await fetch_display_app_name(log, request_context, alert_payload[APP], async_splunk_client)
    notification = Notification(alert_id=configuration[ALERT_ID],
                                severity=configuration[SEVERITY],
                                description=configuration[ALERT_MESSAGE],
                                title=configuration[SUBJECT],
                                created_at=configuration[ALERT_TIMESTAMP_FIELD],
                                call_to_action=call_to_action,
                                app_name=alert_payload[APP],
                                display_app_name=display_app_name)

    detail = Detail(results_link=alert_payload[RESULTS_LINK],
                    search_id=alert_payload[SEARCH_ID],
                    owner=alert_payload[OWNER],
                    dashboard_id=dashboard_url,
                    dashboard_description=dashboard_tuple.dashboard_description,
                    list_dashboard_data=dashboard_tuple.list_dashboard_data,
                    search_name=alert_payload[SEARCH_NAME],
                    result_json=alert_payload[SAVED_SEARCH_RESULT])

    alert = Alert(notification=notification, detail=detail)
    return alert

